import * as fs from "fs";
import * as path from "path";
import * as yaml from "yaml";
import { BootConfig, HubCIConfig, HubCIStep, HubPRTemplateConfig, HubPRTemplateSection } from "../types";
import { detectPackageManager } from "./config";

export const DEFAULT_HUB_TARGETS = [".github", ".forgejo"];

const CI_SCRIPTS = ["lint", "test", "build", "typecheck", "type-check", "check"];

// ────────────────────────────────────────────────
// Detection
// ────────────────────────────────────────────────

/**
 * Detect CI steps from package.json scripts.
 */
export function detectCISteps(cwd: string, config?: BootConfig): HubCIStep[] {
  const pm = config?.packageManager || detectPackageManager(cwd);
  const ciSteps: HubCIStep[] = [];
  const seen = new Set<string>();

  const rootPkg = readPackageJson(cwd);
  if (rootPkg?.scripts) {
    for (const script of CI_SCRIPTS) {
      if (rootPkg.scripts[script] && !seen.has(script)) {
        seen.add(script);
        ciSteps.push({
          name: capitalize(script),
          run: pmRun(pm, script),
        });
      }
    }
  }

  if (ciSteps.length === 0) return [];

  return [{ name: "Install", run: `${pm} install` }, ...ciSteps];
}

/**
 * Detect the Node.js version from engines, .nvmrc, or .node-version.
 */
export function detectNodeVersion(cwd: string): string | null {
  const nvmrc = path.join(cwd, ".nvmrc");
  if (fs.existsSync(nvmrc)) {
    const v = fs.readFileSync(nvmrc, "utf-8").trim().replace(/^v/i, "");
    if (v) return v;
  }

  const nodeVersion = path.join(cwd, ".node-version");
  if (fs.existsSync(nodeVersion)) {
    const v = fs.readFileSync(nodeVersion, "utf-8").trim().replace(/^v/i, "");
    if (v) return v;
  }

  const pkg = readPackageJson(cwd);
  if (pkg?.engines?.node) {
    const match = pkg.engines.node.match(/(\d+)/);
    if (match) return match[1];
  }

  return null;
}

// ────────────────────────────────────────────────
// Generators
// ────────────────────────────────────────────────

/**
 * Generate a CI workflow YAML string.
 * Output is the same for GitHub and Forgejo (they share the Actions format).
 */
export function generateCIWorkflow(ci: HubCIConfig, cwd: string, config?: BootConfig): string {
  const pm = config?.packageManager || detectPackageManager(cwd);
  const triggers = ci.on || ["push", "pull_request"];
  const nodeVersion = ci.node || detectNodeVersion(cwd) || "18";
  const steps = ci.steps || [];

  const on: Record<string, any> = {};
  for (const trigger of triggers) {
    on[trigger] = { branches: ["main"] };
  }

  const jobSteps: any[] = [
    { uses: "actions/checkout@v4" },
    {
      uses: "actions/setup-node@v4",
      with: { "node-version": nodeVersion },
    },
  ];

  if (pm === "pnpm") {
    jobSteps.push({
      uses: "pnpm/action-setup@v4",
    });
  }

  for (const step of steps) {
    jobSteps.push({ name: step.name, run: step.run });
  }

  const workflow = {
    name: "CI",
    on,
    jobs: {
      ci: {
        "runs-on": "ubuntu-latest",
        steps: jobSteps,
      },
    },
  };

  const header = "# Generated by `boot hub` — do not edit directly.\n# Update boot.yaml and run `boot hub sync` to regenerate.\n\n";
  return header + yaml.stringify(workflow, { indent: 2, lineWidth: 0 });
}

export const DEFAULT_PR_TEMPLATE_SECTIONS: HubPRTemplateSection[] = [
  { name: "Summary", prompt: "What changed and why?" },
  {
    name: "Prompt context",
    prompt: "Key prompts or decisions from AI conversations.",
    optional: true,
  },
  { name: "Test plan", prompt: "How was this tested?" },
];

/**
 * Generate a PR template markdown string from the config sections.
 */
export function generatePRTemplate(prTemplate: HubPRTemplateConfig): string {
  const sections = prTemplate.sections || DEFAULT_PR_TEMPLATE_SECTIONS;
  const lines: string[] = [];

  lines.push(
    "<!-- Generated by `boot hub` — do not edit directly. -->",
    "<!-- Update boot.yaml and run `boot hub sync` to regenerate. -->",
    ""
  );

  for (const section of sections) {
    const heading = section.optional
      ? `## ${section.name} (optional)`
      : `## ${section.name}`;
    lines.push(heading);
    if (section.prompt) {
      lines.push(`<!-- ${section.prompt} -->`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

// ────────────────────────────────────────────────
// Sync & Check
// ────────────────────────────────────────────────

export interface HubSyncResult {
  written: string[];
  skipped: string[];
}

/**
 * Write hub config to all configured targets.
 */
export function syncHubTargets(
  config: BootConfig,
  cwd: string,
  options: { overwrite?: boolean } = {}
): HubSyncResult {
  const overwrite = options.overwrite === true;
  const targets = config.hub?.targets || DEFAULT_HUB_TARGETS;
  const ci = config.hub?.ci;
  const prTemplate = config.hub?.prTemplate;
  const written: string[] = [];
  const skipped: string[] = [];

  const hasCISteps = ci && ci.steps && ci.steps.length > 0;
  const ciContent = hasCISteps ? generateCIWorkflow(ci!, cwd, config) : null;
  const prContent = prTemplate ? generatePRTemplate(prTemplate) : null;

  for (const target of targets) {
    if (ciContent) {
      writeTargetFile(target, getHubWorkflowFile, ciContent, cwd, overwrite, written, skipped);
    }
    if (prContent) {
      writeTargetFile(target, getHubPRTemplateFile, prContent, cwd, overwrite, written, skipped);
    }
  }

  return { written, skipped };
}

function writeTargetFile(
  target: string,
  getFile: (target: string) => string | null,
  content: string,
  cwd: string,
  overwrite: boolean,
  written: string[],
  skipped: string[]
): void {
  const file = getFile(target);
  if (!file) return;

  const fullPath = path.join(cwd, file);

  if (fs.existsSync(fullPath) && !overwrite) {
    skipped.push(file);
    return;
  }

  const dir = path.dirname(fullPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(fullPath, content);
  written.push(file);
}

/**
 * Check if hub target files are in sync with the current config.
 */
export function checkHubSync(
  config: BootConfig,
  cwd: string
): { missing: string[]; stale: string[]; ok: string[] } {
  const targets = config.hub?.targets || DEFAULT_HUB_TARGETS;
  const ci = config.hub?.ci;
  const prTemplate = config.hub?.prTemplate;
  const result = { missing: [] as string[], stale: [] as string[], ok: [] as string[] };

  const hasCISteps = ci && ci.steps && ci.steps.length > 0;
  const ciExpected = hasCISteps ? generateCIWorkflow(ci!, cwd, config) : null;
  const prExpected = prTemplate ? generatePRTemplate(prTemplate) : null;

  for (const target of targets) {
    if (ciExpected) {
      checkTargetFile(target, getHubWorkflowFile, ciExpected, cwd, result);
    }
    if (prExpected) {
      checkTargetFile(target, getHubPRTemplateFile, prExpected, cwd, result);
    }
  }

  return result;
}

function checkTargetFile(
  target: string,
  getFile: (target: string) => string | null,
  expected: string,
  cwd: string,
  result: { missing: string[]; stale: string[]; ok: string[] }
): void {
  const file = getFile(target);
  if (!file) return;

  const fullPath = path.join(cwd, file);

  if (!fs.existsSync(fullPath)) {
    result.missing.push(file);
  } else {
    const existing = fs.readFileSync(fullPath, "utf-8");
    if (existing.trim() === expected.trim()) {
      result.ok.push(file);
    } else {
      result.stale.push(file);
    }
  }
}

// ────────────────────────────────────────────────
// Helpers
// ────────────────────────────────────────────────

function getHubWorkflowFile(target: string): string | null {
  if (target === ".github") return ".github/workflows/ci.yml";
  if (target === ".forgejo") return ".forgejo/workflows/ci.yml";
  return null;
}

function getHubPRTemplateFile(target: string): string | null {
  if (target === ".github") return ".github/PULL_REQUEST_TEMPLATE.md";
  if (target === ".forgejo") return ".forgejo/PULL_REQUEST_TEMPLATE.md";
  return null;
}

function readPackageJson(dir: string): any | null {
  const pkgPath = path.join(dir, "package.json");
  if (!fs.existsSync(pkgPath)) return null;
  try {
    return JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
  } catch {
    return null;
  }
}

function pmRun(pm: string, script: string): string {
  if (pm === "npm") return `npm run ${script}`;
  return `${pm} ${script}`;
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
